% !TeX root=../main.tex

\chapter{مقدمه و بیان مساله}
% دستور زیر باعث عدم‌نمایش شماره صفحه در اولین صفحه‌ی این فصل می‌شود.
%\thispagestyle{empty}
\section{مقدمه}
هر روزه برنامه‌های بیشتری تحت وب ساخته می‌شود که به صورت کاملا مستقل از هم مستقر می‌شوند و با استفاده از
\gls{RPC}
با هم ارتباط برقرار می‌کنند. پیدایش روش‌های کم‌هزینه مجازی‌سازی (برای مثال
\glspl{Container})
امکان به کارگیری تعداد زیادی سرویس ریزدانه را فراهم کرده‌اند که آن‌ها را میکروسرویس می‌نامند. شکستن برنامه‌ها به این شکل سودهای بسیاری خواهد داشت:‌ در این صورت مقیاس‌پذیری ساده می‌شود (هر سرویس به طور مستقل می‌تواند رشد کند)،‌ انعطاف‌پذیری بیشتری در تخصیص منابع و زمان ارائه می‌شود، امکان استفاده مجدد از کدها بیشتر می‌شود، امکان استفاده از روش‌های جدید تحمل خطا به وجود خواهد آمد، و امکان استفاده از سرویس‌های خارجی مانند
\lr{Amazon S3}
میسر می‌شود. در نتیجه این معماری توسط تعداد زیادی از شرکت‌های بزرگ و استارتاپ‌ها استفاده می‌شود (برای مثال
\lr{Uber} \cite{toddhoff2020}
و
\lr{Netflix} \cite{tonymauro2020})
و همینطور در مقیاس‌های بسیار بزرگی نیز استقرار یافته است (برای مثال برنامه شرکت
\lr{Uber} \cite{toddhoff2020}
از بیش از ۱۰۰۰ میکروسرویس تشکیل شده است).

در این تحقیق ما قصد داریم تا امکان درستی‌سنجی برنامه‌های مبتنی بر معماری میکروسرویس را بررسی کنیم و روشی برای انجام این کار ارائه دهیم.

\section{تاریخچه‌ای از موضوع تحقیق}
معماری میکروسرویس یک معماری بسیار جدید است که در چند سال اخیر به سبب رشد سریع برنامه‌های تحت وب شکل گرفته است. به همین سبب کارهای زیادی روی درستی‌سنجی برنامه‌های با این معماری صورت نگرفته است. در اینجا ما از بررسی روش‌های درستی‌سنجی سیستم‌های توزیع‌شده صرف نظر می‌کنیم و فقط روی درستی‌سنجی نرم‌افزارهای با معماری میکروسرویس تمرکز خواهیم کرد.

سیستم
ucheck \cite{panda2017verification}
یک سیستم برای درستی‌سنجی میکروسرویس‌ها است. این سیستم،‌ به صورت جدا از میکروسرویس‌ها مستقر می‌شود و با مانیتور کردن ترافیک شبکه و پیام‌های رد و بدل شده، سعی در بررسی درستی شرط‌های تعریف شده را دارد. این سیستم از استدلال
\lr{rely-guarantee} \cite{Jones83}
برای شرط‌ها استفاده می‌کند. به دلیل پیچیدگی پیاده‌سازی تحلیل ترافیک شبکه، این سیستم هیچ پیاده‌سازی در دسترسی ندارد. همینطوری استدلال
\lr{rely-guarantee}
برای بررسی دقیق سیستم‌های توزیع‌شده طراحی شده و نوشتن شرط‌های مناسب در آن، کاری بسیار دشوار است.

سیستم
Whip \cite{waye2017whip}
یک سیستم دیگر برای درستی‌سنجی میکروسرویس‌هاست. این سیستم هم مانند ucheck سعی می‌کند تا با تحلیل ترافیک شبکه عمل درستی‌سنجی را انجام دهد و به همین علت پیاده‌سازی مناسب استفاده عملیاتی ندارد. Whip از قراردادها برای توصیف شرط‌ها استفاده می‌کند و روشی برای توصیف قراردادهای سطح‌ بالا ارائه می‌دهد که از آن برای
\gls{BlameAssignment}
دقیق‌تر استفاده می‌کند.

\section{شرح مسئله تحقیق}
با بزرگ شدن اندازه برنامه و بیشتر شدن پیچیدگی‌های آن، اطمینان از درستی این برنامه‌های مبتنی بر معماری میکروسرویس برای گردانندگان آن سخت‌تر می‌شود. ویژگی‌های این برنامه‌ها، وابسته است به رفتار هر کدام از میکروسرویس‌های تشکیل دهنده آن، و تنظیمات مربوط به ارتباطات بین آن‌ها. فهمیدن برقراری یک شرط خاص در هنگام اجرای یک برنامه یک مساله غیربدیهی برای برنامه‌های کوچک است، اما برای برنامه بزرگی که از تعدادی زیاد میکروسرویس تشکیل شده است، بسیار سخت است. برای مثال، یک برنامه ساده را در نظر بگیرید که از سه سرویس تشکیل شده است: یک وب‌سرور، یک سرویس احراز هویت و یک پایگاه داده. اطمینان از این شرط که تنها کاربرانی که احراز هویت آن‌ها تایید شده است، می‌توانند پایگاه داده را به‌روزرسانی کنند، نیازمند دسترسی به وضعیت وب‌سرور (برای تعیین درخواستی که موجب به‌روزرسانی شده است) و سرویس احراز هویت (برای بررسی احراز هویت درخواست‌دهنده)‌ علاوه بر نیازمندی دسترسی به پایگاه داده است. حتی اگر تمامی میکروسرویس‌ها هم روش‌هایی را برای دسترسی به وضعیت‌شان ارائه کنند، باز هم نیاز داریم تا آن‌ها را با هم هماهنگ کنیم تا یک تصویر نامتناقض از کل برنامه به دست آوردیم. استفاده از چنین روش‌هایی در برنامه‌های بزرگ، بسیار ناکارآمد خواهد بود.

\section{تعریف موضوع تحقیق}
در قسمت‌های قبل، به نیاز به درستی‌سنجی برنامه‌های با معماری میکروسرویس و پیچیدگی‌های آن اشاره شد. در این تحقیق ما روی موضوع درستی‌سنجی نرم‌افزارهای با معماری میکروسرویس تمرکز می‌کنیم. در این تحقیق ما سعی می‌کنیم که در یک برنامه‌ بزرگ با تعداد سرویس‌های بسیار زیاد، از برقراری شرط‌های مهمی که توسط کاربر تعیین می‌شوند، اطمینان حاصل کنیم.

\section{اهداف و آرمان‌های کلی تحقیق}
در این تحقیق ما یک روش برای درستی‌سنجی برنامه‌های با معماری میکروسرویس ارائه می‌کنیم به گونه‌ای که مشکلات تحقیقات قبلی را نداشته باشد. در این تحقیق ما روی درستی‌سنجی ارتباط بین میکروسرویس‌ها تمرکز می‌کنیم چرا که پیچیدگی اصلی در در این معماری، ارتباطات زیاد بین تعداد زیاد سرویس است که روی شبکه و با استفاده از
\gls{RPC}
با هم صحبت می‌کنند. همینطور به دلیل اینکه این مسئله، یک مسئله کاربردی مهندسی نرم‌افزار است، وجود یک پیاده‌سازی مناسب برای محیط‌های عملیاتی بخش مهمی از تحقیق است. به همین دلیل،‌ ارائه یک پیاده‌سازی مناسب از اهداف اصلی این تحقیق است.

\section{روش انجام تحقیق}
با توجه به اهداف گفته شده، ما استفاده از قراردادها را برای نوشتن شرط‌ها و بررسی آن‌ها انتخاب کردیم. طراحی توسط قرارداد روش قدرتمندی است که با استفاده از آن به خوبی می‌توان شرط‌های لازم را برای
\glspl{RemoteProcedureCall}
نوشت. ما این شرط‌ها در زمان اجرای برنامه بررسی می‌کنیم و در صورت نقض شدن هر شرط، آن را به توسعه‌دهنده اطلاع می‌دهیم. در این اشکالات در کل سیستم پخش نمی‌شوند و توسعه‌دهنده در اولین فرصت متوجه آن‌ها می‌شود. همچنین در روش ما این امکان وجود دارد که بتوان روی ترتیب اجرا
\gls{RPC}ها
شرط نوشت. این موضوع کمک می‌کند که بسیار بهتر بتوان ارتباط میان میکروسرویس‌ها را درستی‌سنجی کرد.

سپس برای روش ارائه شده، یک پیاده‌سازی در زبان برنامه‌نویسی
Go \cite{golang}
و برای چارچوب
gRPC \cite{grpc}
ارائه می‌دهیم و سپس با استفاده از آن به درستی‌سنجی یک برنامه با معماری میکروسرویس می‌پردازیم و نشان می‌دهیم که چگونه در آن اشکالاتی را پیدا کردیم. در نهایت سربار روشمان را روی کارایی برنامه بررسی می‌کنیم و نشان می‌دهیم که روش ما سربار بسیار کمی خواهد داشت.

\section{ساختار پایان‌نامه}
در فصل دوم مفاهیم و تعاریف اساسی مربوط به میکروسرویس‌ها، درستی‌سنجی و طراحی بر اساسی قرارداد ارائه می‌شود. فصل سوم دربرگیرنده توضیحات مربوط به روش پیشنهادی و کتابخانه پیاده‌سازی شده است. در این فصل چگونگی تعریف شرط‌ها برای درستی‌سنجی را به دقت بررسی می‌کنیم. در فصل چهارم روش ارائه شده در یک پروژه واقعی پیاده می‌شود و می‌بینیم که چگونه توانستیم چندین اشکال در این پروژه بزرگ را پیدا کنیم. سپس سربار روش ارائه شده از نظر زمانی و حافظ بررسی می‌شود و می‌بینیم که این سربار بسیار ناچیز است. در نهایت، در فصل پنجم، نتیجه‌گیری‌های کلی حاصل شده در این تحقیق، نوآوری‌های انجام‌شده و محدودیت‌ها مورد بحث قرار می‌گیرد و پیشنهادهایی برای ادامه این تحقیق ارائه خواهد شد.
