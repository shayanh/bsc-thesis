% !TeX root=../main.tex
\chapter{مفاهیم اولیه و پیش‌زمینه}
%\thispagestyle{empty} 

\section{مقدمه}
در این فصل برای روشن‌شدن مفاهیم و اصطلاحات حول موضوع این پژوهش، به تعریف برخی مفاهیم اساسی که پیش‌نیاز درک این پروژه هستند می‌پردازیم.

\section{معماری میکروسرویس}
میکروسرویس، همان طور که از نام آن مشخص می‌شود، اساساً به سرویس‌های نرم‌افزاری مستقلی گفته می‌شود که کارکردهای تجاری خاصی را در یک اپلیکیشن نرم‌افزاری ارائه می‌کنند. این سرویس‌ها می‌توانند به صورت مستقل از هم نگهداری، نظارت و توزیع شوند.

\gls{ServiceOrientedArchitecture}
به اپلیکیشن‌ها امکان ارتباط با یکدیگر روی یک رایانه منفرد و یا در زمان توزیع اپلیکیشن‌ها روی چندین رایانه در یک شبکه را ارائه می‌کند. هر میکروسرویس ارتباط اندکی با سرویس‌های دیگر دارد. این سرویس‌ها خودکفا هستند و یک کارکرد منفرد (یا گروهی از کارکردهای مشترک) را ارائه می‌کنند.

معماری میکروسرویس‌ها به طور طبیعی در سازمان‌های بزرگ و پیچیده استفاده می‌شود که در آن‌ها چند تیم توسعه می‌توانند مستقل از هم برای ارائه یک کارکرد تجاری کار بکنند و یا اپلیکیشن‌ها ملزم به ارائه خدمات به یک حوزه تجاری باشند.

پیش از آن که بخواهیم به توضیح مسائلی که میکروسرویس برای حل آن‌ها ابداع شده بپردازیم، باید تاریخچه تکامل نرم‌افزار را به طور خلاصه مرور کنیم.

\subsection{تکامل رایانه‌ها}
زمانی که رایانه‌ها برای اولین بار در دهه 1940 میلادی ارائه شدند، نرم‌افزار به صورت پانچ شده درون سخت‌افزارهای بزرگ و گران‌قیمت مانند کارت‌های پانچ و نوارهای پانچ جاسازی شده بود. دستورالعمل‌ها به زبان ماشین باینری نوشته شده بودند. متعاقباً اگر لازم می‌شد تغییری پیاده‌سازی شود، یک کارشناس زبان باینری ماشین باید دستورالعمل‌های جدید را در اختیار ماشین قرار می‌داد. این امر یک فرایند بسیار گران‌قیمت بود.

سپس نسل دوم رایانه‌ها در دهه 1950 میلادی به عنوان نسخه بهبود یافته نسل اول رایانه‌ها معرفی شدند. این رایانه‌ها به برنامه‌هایی با زبان اسمبلی نیاز داشتند که در تراشه‌های سخت‌افزاری کوچک‌تری نوشته می‌شد. فلسفه طراحی این رایانه‌ها پیرامون این واقعیت شکل گرفته بود که یادگیری زبان نمادین اسمبلی بسیار راحت‌تر از آموختن کدهای باینری است. در نتیجه اسمبلرها معرفی شدند که کد ماشین را به زبان نمادین اسمبلی تبدیل می‌کردند.

در این مورد نیز هر زمان که تغییری مورد نیاز بود، فرد باید دستورالعمل‌ها را در سخت‌افزار وارد می‌کرد. در نتیجه نرم‌افزار و سخت‌افزار باید از همدیگر جدا می‌شدند.

و سپس نسل سوم رایانه‌ها در دهه 1960 میلادی عرضه شدند. این رایانه‌ها به کامپایلر و مفسر برای ترجمه زبان قابل فهم از سوی انسان به کد ماشین نیاز داشتند. این رایانه‌ها کوچک‌تر بودند و می‌بایست نرم‌افزارهای قابل تعامل از سوی کاربر روی آن‌ها نصب می‌شد. نسل سوم رایانه‌ها می‌توانستند چندین اپلیکیشن را همزمان اجرا کنند. زبان‌های برنامه‌نویسی مختلفی معرفی شدند که روی این رایانه‌ها نصب می‌شدند. سخت‌افزار همچنان گران‌قیمت بود؛ اما انعطاف‌پذیری حاصل از جداسازی نرم‌افزار از سخت‌افزار موجب ایجاد فرصت‌های بی‌شماری برای بهبود کارکرد آن‌ها شد.

در نهایت نسل چهارم رایانه‌ها در دهه 1970 میلادی معرفی شدند. این رایانه‌ها دستگاه‌های دستی بودند که می‌توانستند در کف دست جای بگیرند. در این مورد نیز اپلیکیشن‌های جدید معرفی شدند که می‌توانستند روی دستگاه‌ها بدون نیاز به خرید سخت‌افزار جدید نصب شوند. سهولت نصب و قابلیت نگهداری موجب شد که بسیاری از شرکت‌ها بتوانند ایده‌های فناورانه جدیدی را ابداع کنند.

یک طرح مشترک وجود دارد. رایانه‌ها به این دلیل تکامل یافتند که همواره نیاز به نگهداری و بهبود اپلیکیشن‌های نصب شده روی رایانه‌ها وجود داشته است.
\cite{malik2020}

\subsection{تکامل نرم‌افزار}
تکامل نرم‌افزار نیز چرخه مشابه را طی کرده است.
\begin{itemize}

\item
\textbf{
نسل اول (اواخر دهه 1970 میلادی):
}
مفاهیم شیءگرایی مانند وراثت، کپسوله‌سازی، و چندریختی معرفی شدند تا قابلیت استفاده مجدد از کد و قابلیت نگهداری فراهم شوند.

\item
\textbf{
نسل دوم (دهه 1990 میلادی):
}
اپلیکیشن‌ها با استفاده از معماری لایه‌بندی شده طراحی و پیاده‌سازی شدند. معماری لایه‌بندی شده برای کاهش در هم تنیدگی زیاد بین اجزای مختلف اپلیکیشن‌های نرم‌افزاری معرفی شد. در نتیجه تست نرم‌افزار و زمان برای تحویل نرم‌افزار کاهش یافت. اپلیکیشن‌ها همچنان یکپارچه بودند، یعنی یک واحد منفرد که همه کارکردهای اپلیکیشن وجود داشت در آن کپسوله‌سازی شده بود.

\item
\textbf{
نسل سوم (دهه 2000 میلادی):
}
در این زمان اپلیکیشن‌های با توزیع مبتنی بر سرویس معرفی شدند. روش طراحی مورد استفاده در این نسل شامل تعریف سرویس از راه دور بود که به اپلیکیشن‌ها امکان مقیاس‌بندی و توزیع روی ماشین‌های چندگانه را می‌داد.
\cite{malik2020}

\end{itemize}

پیش از معرفی میکروسرویس‌ها، اغلب اپلیکیشن‌ها از
\gls{MonolithicArchitecture}
استفاده می‌کردند. در ادامه مشکلات این معماری را با توجه به نیازمندی‌های جدید بررسی می‌کنیم.

\subsection{معماری یک‌پارچه}
یک برنامه با معماری یک‌پارچه از چندین لایه تشکیل می‌شود و هر لایه در کد نرم‌افزاری پیاده‌سازی می‌شد و از چندین کلاس و
\gls{Interface}
تشکیل یافته بود:

\begin{itemize}

\item
\textbf{
لایه داده:
}
این لایه برای ذخیره‌سازی داده‌ها در پایگاه داده و فایل‌ها پیاده‌سازی شده است. تنها مسئولیت این لایه ارائه داده‌ها از منابع داده‌ای مختلف است.

\item
\textbf{
لایه تجاری:
}
مسئولیت لایه تجاری، بازیابی داده‌ها از لایه داده و اجرای محاسبات است. لایه تجاری نمی‌داند که داده‌ها در فایل یا پایگاه داده یا در موارد دیگر هستند. لایه تجاری به لایه داده‌ها وابسته است.

\item
\textbf{
لایه سرویس:
}
لایه سرویس روی لایه تجاری قرار می‌گیرد. این لایه یک پوشش برای لایه تجاری ایجاد می‌کند که شامل امنیت/گزارش‌گیری/وساطت برای فراخوانی کارکردها است. لایه سرویس به لایه تجاری وابسته است.

\item
\textbf{
لایه رابط کاربری:
}
لایه اینترفیس یا رابط کاربری شامل کدهایی است که در لایه میزبانی مورد ارجاع قرار می‌گیرند و به منظور ایجاد امکان تعامل با اپلیکیشن برای کاربران طراحی شده است.

\end{itemize}

این طراحی به توسعه‌دهندگان امکان می‌دهد که روی یک کارکرد خاص متمرکز شوند، ویژگی را تست کنند، و یا اپلیکیشن را با استفاده از کنترل معکوس از طریق
\glspl{DependencyInjection}
و میزبانی یک اپلیکیشن روی ماشین‌های متعدد تجزیه کنند.
\cite{fowler_patterns_2003}

طراحی یکپارچه لایه‌بندی شده مزایای زیادی دارد؛ اما نواقصی نیز دارد. در ادامه فهرستی از مشکلات رایج این نوع معماری را مورد اشاره قرار داده‌ایم:
\begin{enumerate}

\item
این طراحی برای مقیاس‌بندی و نگهداری اپلیکیشن سرراست نیست. این طراحی زمان مورد نیاز برای قرار دادن کارکردهای جدید در اختیار کاربر را افزایش داده است، چون چرخه توسعه زمان بیشتری طول می‌کشد.

\item
از آنجا که کل اپلیکیشن به صورت یک پردازش منفرد میزبانی می‌شود، هر بار که لازم باشد یک به‌روزرسانی اجرا شود، کل اپلیکیشن باید متوقف شود و سپس نسخه جدیدی از اپلیکیشن باید توزیع شود.

\item
برای ایجاد تعادل در بار کاری، کل اپلیکیشن نرم‌افزاری روی چند ماشین توزیع می‌شود. به علاوه، امکان توزیع کارکردهای خاص روی سرورهای چندگانه برای متوازن‌سازی بار وجود ندارد.

\item
طراحی اپلیکیشن پیچیده است، چون همه ویژگی‌ها در یک اپلیکیشن یکپارچه منفرد پیاده‌سازی شده‌اند.

\item
زمانی که تعداد اپلیکیشن‌ها در سازمان افزایش می‌یابد، توزیع اپلیکیشن‌های یکپارچه نیازمند اطلاع‌رسانی و هماهنگی با همه تیم‌های توسعه ویژگی‌های جدید است. این امر موجب افزایش زمان مورد نیاز برای تست و توزیع اپلیکیشن می‌شود.

\item
بدین ترتیب در طراحی یک
\gls{SinglePointOfFailure}
ایجاد می‌شود که یک خطای غیر قابل بازیابی منفرد نمی‌تواند پردازشی را که اپلیکیشن روی آن میزبانی شده است متوقف کند.

\item
این معماری اپلیکیشن را وادار می‌کند که در یک مجموعه فناوری منفرد پیاده‌سازی شود.

\item
در مواردی که زمان تحویل طولانی‌تر شود، در طی زمان نیازمند پول بیشتری برای توسعه و نگهداری اپلیکیشن خواهد بود.

\item
از آنجا که همه کد درون یک اپلیکیشن منفرد قرار دارد، نگهداری کد پس از مدتی به سرعت دشوار می‌شود.

\end{enumerate}

\subsection{معماری میکروسرویس}

به طور خلاصه یک مفهوم وجود دارد و آن این است که ما همواره ملزم هستیم نرم‌افزار را نگهداری و به‌روزرسانی کنیم. باید فرایند بهبود اپلیکیشن‌ها را آسان‌تر و مقدار زمان مورد نیاز برای ارائه نسخه‌های جدید اپلیکیشن‌ها را کوتاه‌تر کنیم.

میکروسرویس‌ها برای حل مسائل اشاره شده فوق معرفی شده‌اند. معماری میکروسرویس یک بهینه‌سازی در زمینه معماری فوق‌الذکر محسوب می‌شود. در این معماری هر کارکرد تجاری به صورت یک سرویس ارائه می‌شود. هر سرویس می‌تواند به صورت مستقل از سرویس‌های دیگر میزبانی و توزیع شود.

به عنوان مزیت‌های استفاده از این معماری، می‌توان به موارد زیر اشاره کرد:
\begin{itemize}

\item
همه سرویس‌ها می‌توانند حتی زمانی که سرویس‌ها روی ماشین‌های مختلف هستند، با همدیگر ارتباط داشته باشند. این وضعیت در ادامه امکان پیاده‌سازی کارکردهای جدید در سرویس‌ها را فراهم می‌سازد.

\item
میکروسرویس‌ها، سازمان‌ها را تشویق می‌کنند که از فرایند توزیع و تحویل پیوسته خودکار پیروی کنند.

\item
اپلیکیشن‌ها در نهایت بسیار پایدارتر می‌شوند، چون هر ویژگی می‌تواند به صورت مستقلانه تست و توزیع شود.

\item
از آنجا که هر سرویس روی پردازش مجزایی میزبانی می‌شود، اگر یک سرویس به نقطه تنگنای اپلیکیشن تبدیل شود و به منابع زیادی نیاز داشته باشد، در این صورت می‌توان آن را بدون هیچ گونه تأثیر سوء روی سرویس‌های دیگر، به ماشین دیگری انتقال داد.

\item
زمانی که کاربران بیشتری شروع به استفاده از یک ویژگی اپلیکیشن بکنند، آن سرویس می‌تواند با توزیع روی رایانه‌های قدرتمندتر یا از طریق استفاده از
\gls{Cache}
بدون این که روی سرویس‌های دیگر هیچ تأثیری بگذارد، مقیاس‌بندی شود.

\item
این معماری پایداری اپلیکیشن را نیز افزایش می‌دهد، چون هر سرویس می‌تواند به صورت مستقلانه ساخته، تست، توزیع و استفاده شود.

\item
کد اپلیکیشن می‌تواند به سادگی نگهداری شود و پردازش‌ها می‌توانند به صورت مجزا تحت نظارت قرار بگیرند.

\item
توسعه‌دهندگان اختصاصی می‌توانند سرویس‌ها را به صورت مستقل از هم پیاده‌سازی کرده و این سرویس‌ها را بدون تأثیرگذاری روی سرویس‌های دیگر انتشار دهند.

\item
بدین ترتیب نقطه شکست منفرد نیز از بین می‌رود، زیرا یک سرویس می‌تواند بدون تأثیرگذاری روی ویژگی‌های دیگری که اپلیکیشن نرم‌افزاری ارائه می‌کند، متوقف شود.

\item
در نتیجه این طراحی زمان مورد نیاز برای تحویل نسخه‌های جدید را کاهش می‌دهد و بنابراین هزینه را در طی زمان کاهش می‌دهد.

\item
قابلیت استفاده مجدد از کد افزایش می‌یابد، زیرا یک ویژگی به صورت سرویس میزبانی شده است و امکان استفاده چند سرویس از یک ویژگی به جای پیاده‌سازی مجدد کد در هر مورد وجود دارد.

\item
معماری مبتنی بر سرویس امکان استفاده از مجموعه متنوعی از فناوری برای رفع نیازها وجود دارد. به عنوان نمونه بسته‌های تحلیل داده زبان R یا پایتون می‌توانند به صورت مجزا توزیع و میزبانی شوند و همزمان می‌توان از 
\lr{C\#.Net}
برای پیاده‌سازی سرویس‌ها استفاده کرد. به علاوه می‌توان از NodeJS در سمت سرور استفاده کرد و AngularJs و ReactJs نیز برای پیاده‌سازی رابط کاربری مورد استفاده قرار گیرند. هر ویژگی تجاری می‌تواند با استفاده از مجموعه مختلفی و از طریق تیم متفاوتی، مستقل از ویژگی‌های دیگر پیاده‌سازی شود.

\end{itemize}


\section{درستی‌سنجی نرم‌افزار}
درستی‌سنجی نرم‌افزار یکی از بخش‌های مهندسی نرم‌افزار است که هدف آن اطمینان حاصل کردن از این است که نرم‌افزار تمام نیازمندی‌های تعریف شده را برآورده کند. درستی‌سنجی نرم‌افزار می‌توان به دو صورت ایستا و پویا انجام داد. در درستی‌سنجی ایستا قبل از اجرای برنامه، بررسی صورت می‌گیرد و در درستی‌سنجی پویا، بررسی برنامه در هنگام اجرای آن صورت می‌گیرد. 

هدف درستی‌سنجی پویا پیدا کردن اشکالات برنامه در زودترین زمان ممکن است و قبل اینکه آن‌ها در تمام برنامه منتشر شوند. در ادامه یکی از قوی‌ترین روش‌های درستی‌سنجی پویا، به نام طراحی بر اساس قرارداد
\cite{meyer1997object, mandrioli1992advances, meyer1992applying}
را بررسی می‌کنیم.

\subsection{طراحی بر اساس قرارداد}

قرارداد در واقع تشبیهی از زندگی روزمره است. قرارداد چیزی است که همه‌ی ما با آن آشنایی داریم. منظور این است که زمانی که با یک شئ تعامل می‌کنید، شما به عنوان فراخواننده، و شئ به عنوان آن‌چه فراخوانده می‌شود، روی یک قرارداد توافق می‌کنید. این شئ است که مفاد قراداد را تعیین می‌کند و شما یا باید آن را بپذیرید یا از آن استفاده نکنید. هر تابع از یک شئ تضمین می‌کند اگر شما به عنوان فراخواننده به بخش‌های مربوط به خود از قرداد پایبند باشید (اگر 
\glspl{Precondition}
مورد نیاز آن شئ را برآورده کنید) کار خود را انجام دهد. مسئله‌ی مهم این است که مانند زندگی روزمرّه، قرارداد چیزی دوطرفه است. فقط این نیست که شئ کاری را انجام دهد و من به عنوان فراخواننده وظایفم را انجام ندهم. این‌طور هم نیست که من به عنوان فراخواننده وظایفم را انجام دهم و شئ به دلخواه خود عمل کند - مثلاً اگر من یک اتاق را اجاره کنم، کلیدش را می‌گیرم و می‌توانم در آن زندگی کنم، اما به شرط اینکه اجاره‌اش را پرداخت کنم - بنابراین کاملاً دو طرفه است، فکر کردن به آن این‌گونه است.


پیش و پس‌شرط‌ها عبارات
\gls{Boolean}
هستند. هر تابع لیستی از پیش‌شرط‌ها (لیستی از عبارات که حاصل آن یک مقدار بولین است) را دارد. حاصل این لیست پیش‌شرط‌ها هنگام فراخوانی باید مقداری درست باشد. لیست دیگری هم از
\glspl{Postcondition}
 وجود دارد که آن هم لیستی از عبارات بولین است. شئ تضمین می‌کند اگر من پیش‌شرط‌ها را رعایت کنم، حاصل پس‌شرط‌ها هم پس از فراخوانی یک مقدار درست خواهد بود. فکر می‌کنم یک مثال در این‌جا مفید باشد. فرض کنید که یک تابع برای محاسبه‌ی ریشه‌ی دوم یک عدد اعشاری نوع Double داریم. بدیهی است که یک پیش‌شرط این است که پارامتر ورودی باید بزرگ‌تر یا مساوی صفر باشد. پس‌شرط هم این است که اگر نتیجه‌ی برگردانده‌ شده توسط تابع را در خودش ضرب کنم، همان مقدار ورودی حاصل شود. البته در واقع هیچ‌وقت دقیقاً همان عدد حاصل نخواهد شد. بنابراین اگر پس‌شرط را به صورت رسمی بیان شود باید گفت تفاوت میان نتیجه و عدد مورد نظر باید کم‌تر از یک عدد مشخص باشد. بنابراین شما دقتی برای محاسبات تابع تعیین می‌کنید. و این یکی از ارزش‌های مشخص کردن پیش و پس‌شرط‌ها به صورت رسمی را نشان می‌دهد، چون دقت عملیات را به صراحت در امضای تابع بیان می‌کند که در بسیاری از موارد مفید است.
بیشتر اوقات پس‌شرط‌های 
\gls{Functional}
را بررسی می‌کنید. به طور خاص این‌که مقدار محاسبه شده برخی شرایط را ارضا می‌کند اما گاهی اوقات هم افراد روی شرایط 
\gls{NonFunctional}
کار می‌کنند، مثلاً تعداد چرخه‌های پردازنده که این عملیات به طول می‌انجامد،‌ اما عموماً این پیش و پس‌شرط‌ها عملیاتی هستند.

\singlespacing
\begin{figure}
	\begin{LTR}
		\lstinputlisting[language=JAVA, caption={نمونه قرارداد یافتن ریشه دوم در زبان جاوا}, label={code:javaSqrt}]{sqrt.java}
	\end{LTR}
\end{figure}
\doublespacing

مهم است که بدانیم و مشخص شود پیش و پس‌شرط‌ها بر روی چه داده‌هایی می‌توانند اعمال شوند. بیایید با پیش‌شرط‌ها شروع کنیم. واضح است که در این مورد پارامترها هستند. در مثال ریشه‌ی دوم این مسئله واضح است که می‌گویید این پارامتر نباید 
\lr{\texttt{Null}}
باشد، یا باید در این بازه قرار بگیرد یا از این قبیل. این‌ها مثال‌های متداولی هستند که عموماً با 
\glspl{Assertion}
بررسی می‌شوند و کد آن‌ها را روی پارامترها اعمال می‌کند. دسته‌ی دیگرِ داده‌ها که پیش‌شرط‌ها می‌توانند روی آن اعمال شوند، وضعیت قابل مشاهده یا وضعیت عمومی شئ است. همان‌طور که در ابتدا گفتیم، موضوع طراحی بر اساس قرداد، واسط‌ها هستند، نه پیاده‌سازی. بنابراین تمام وضعیتی که از طریق واسط قابل دسترسی است، می‌تواند در پیش‌شرط‌ها شرکت داشته باشد. اگر به مثال مجموعه برگردیم، فرض کنید یک تابع 
\lr{\texttt{size()}}
داریم که تعداد عناصر درون مجموعه را از طریق واسط آن در دسترس قرار می‌دهد و تابع دیگری هم به نام
\lr{\texttt{getFirst()}}
داریم و فرض کنیم که قرارداد این مجموعه می‌گوید که در صورتی که مجموعه خالی است
\lr{\texttt{getFirst()}}
نباید فراخوانی شود بنابراین پیش‌شرط آن، به صورت
\lr{\texttt{size() > 0}}
تعریف می‌شود. این تنها راه انجام دادن این کار نیست، دلایل خوبی برای نداشتن چنین پیش‌شرطی وجود دارد. با این حال این کار امکان‌پذیر است. یعنی هیچ‌کس مجاز نیست وقتی مجموعه خالی است تابع
\lr{\texttt{getFirst()}}
را فراخوانی کند. فرض کنید که این مجموعه یک
\gls{Stack}
است و یک تابع
\lr{\texttt{pop()}}
دارد. این که تصور کنیم فراخوانی
\lr{\texttt{pop()}}
در صورتی که پشته خالی باشد مجاز نیست، خیلی متداول است. بنابراین دسترسی به وضعیت داخلی یک شیء از طریق واسط عمومی آن در نوشتن پیش‌شرط‌ها مجاز است. اما این امکان وجود ندارد که در پیش‌شرط‌ها به وضعیت داخلی که در واسط عمومی وجود ندارد ارجاع داشته باشیم. چون پیش‌شرط‌ها جزئی از واسط هستند، و واسط نباید اطلاعی از پیاده‌سازی داشته باشد و باید از آن مستقل باشد.
در مورد پس‌شرط‌ها مسائل کمی پیچیده‌تر هستند. در اینجا هم می‌توان به پارامترها ارجاع داشت. در مثالی که زدیم (مثال یافتن ریشه‌ی دوم یک عدد)، نتیجه‌ی محاسبات (اگر در خودش ضرب شود) باید تقریباً با پارامتر ورودی برابر باشد. بنابراین می‌توانید به حاصل یک تابع نیز دسترسی پیدا کنید، که بدیهی است ضروری است. همچنین می‌توانید به وضعیت شئ قبل و بعد از فراخوانی عملیات دسترسی پیدا کنید. فرض کنید در مثال مجموعه یک تابع
\lr{\texttt{add()}}
داشته باشیم که چیزی به مجموعه اضافه می‌کند. یکی از پس‌شرط‌ها این خواهد بود که اندازه‌ی مجموعه پس از عملیات یکی بیشتر از اندازه‌ی آن قبل از انجام عملیات است. بنابراین این یکی از چیزهایی است که به پیچیدگی‌های پس‌شرط‌ها اضافه می‌کند و در مورد پیش‌شرط‌ها به آن‌ها احتیاجی نیست.
\cite{arno2020}
